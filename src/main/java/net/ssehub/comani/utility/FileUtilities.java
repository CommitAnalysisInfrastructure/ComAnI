/*
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
 * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package net.ssehub.comani.utility;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import net.ssehub.comani.core.Logger;
import net.ssehub.comani.core.Logger.MessageType;

/**
 * This class provides utility methods for creating, deleting, and checking files and directories.
 * 
 * @author Christian Kroeher
 *
 */
public class FileUtilities {

    /**
     * The identifier if this class, e.g. for printing messages.
     */
    private static final String ID = "FileUtilities";
    
    /**
     * Singleton instance of this class.
     */
    private static FileUtilities instance = null;
    
    /**
     * The {@link Logger} for printing messages.
     */
    private Logger logger = Logger.getInstance();
    
    /**
     * Constructs new {@link FileUtilities}.
     */
    private FileUtilities() {}
    
    /**
     * Returns the single instance of the {@link FileUtilities}.
     * 
     * @return the single instance of the {@link FileUtilities}
     */
    public static synchronized FileUtilities getInstance() {
        if (instance == null) {
            instance = new FileUtilities();
        }
        return instance;
    }
    
    /**
     * Writes the given content to the file specified by the given path and file name.
     * 
     * @param path the string representation of the path denoting the location the file shall be saved
     * @param fileName the name of the file to be created or overridden; this name should contain a file extension
     * @param fileContent the content which shall be written to the file
     * @param override specifies whether to override an existing file (<code>true</code>) or not (<code>false</code>)
     * @return <code>true</code> if creating and writing the file was successful; <code>false</code> otherwise 
     */
    public synchronized boolean writeFile(String path, String fileName, String fileContent, boolean override) {
        boolean fileWrittenSuccessfully = false;
        File file = createFile(path, fileName);
        // Keep null-check separately to avoid false warning messages generated by inner check
        if (file != null) {           
            if (override || !file.exists()) {
                Path parentDirectory = file.toPath().getParent();
                try {
                    if (!Files.exists(parentDirectory)) {
                        Files.createDirectories(parentDirectory);
                    }
                    Files.write(file.toPath(), fileContent.getBytes());
                    fileWrittenSuccessfully = true;
                } catch (IOException e) {
                    logger.logException(ID, "Writing content to file \"" + file.getAbsolutePath() + "\" failed", e);
                }
            } else {
                logger.log(ID, "Writing file \"" + file.getAbsolutePath() + "\" denied",
                        "The file already exists and overriding is forbidden",
                        MessageType.ERROR);
            }
        } else {
            logger.log(ID, "Writing to file failed", "The path or file name is empty", MessageType.ERROR);
        }
        return fileWrittenSuccessfully;
    }
    
    /**
     * Reads the content of the given file and returns a list of strings in which each string
     * contains a single line of the content of the file.
     * 
     * @param file the {@link File} the content should be read from
     * @return a {@link List} of {@link String}s representing the line-wise content of the
     *         given file; may return <code>null</code> if the given file cannot be read    
     */
    public synchronized List<String> readFile(File file) {
        List<String> fileLines = null;
        FileReader fileReader = null;
        BufferedReader bufferedReader = null;       
        try {
            fileLines = new ArrayList<String>();
            fileReader = new FileReader(file);
            bufferedReader = new BufferedReader(fileReader);
            String fileLine;
            while ((fileLine = bufferedReader.readLine()) != null) {
                fileLines.add(fileLine);
            }
        } catch (IOException | OutOfMemoryError e) {
            logger.logException(ID, "Reading content from file \"" + file.getAbsolutePath() + "\" failed", e);
        } finally {
            // Close the readers in any case
            if (fileReader != null) {
                try {
                    fileReader.close();
                } catch (IOException e) {
                    logger.logException(ID, "Closing file reader for \"" + file.getAbsolutePath() + "\" failed", e);
                }
            }
            if (bufferedReader != null) {
                try {
                    bufferedReader.close();
                } catch (IOException e) {
                    logger.logException(ID, "Closing buffered reader for \"" + file.getAbsolutePath() + "\" failed", e);
                }
            }
        }
        return fileLines;
    }
    
    /**
     * Creates a new {@link File} based on the given path and file name.
     * 
     * @param path the string representation of the path denoting the location of the file to be created
     * @param fileName the name of the file to be created
     * @return a new file or <code>null</code> if the path or file name is empty
     */
    private File createFile(String path, String fileName) {
        File file = null;
        if (path != null && !path.isEmpty()) {
            if (fileName != null && !fileName.isEmpty()) {
                file = new File(path, fileName);
            } else {
                logger.log(ID, "Cannot create file", "No file name specified", MessageType.ERROR);
            }
        } else {
            logger.log(ID, "Cannot create file", "No path for a file specified", MessageType.ERROR);
        }
        return file;
    }
}
